<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>JV's SpecTape</title>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            /* Authentic Speccy Palette */
            --sp-black: #000000;
            --sp-blue: #0000D7;
            --sp-red: #D70000;
            --sp-magenta: #D700D7;
            --sp-green: #00D700;
            --sp-cyan: #00D7D7;
            --sp-yellow: #D7D700;
            --sp-white: #FFFFFF;
            
            --case-black: #1a1a1a;
            --key-grey: #2d2d2d;
            --safe-area-bottom: env(safe-area-inset-bottom);
        }

        body {
            background-color: #101010;
            color: #ccc;
            font-family: 'Courier New', monospace;
            margin: 0; padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            touch-action: none;
        }

        /* --- THE TV SCREEN --- */
        #viewport {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            padding: 20px;
            transition: background 0s;
            position: relative;
        }

        /* CRT Scanline Effect Overlay */
        #viewport::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 20;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        #stage {
            position: relative;
            width: 320px; height: 240px; /* 4:3 Aspect Ratio */
            background: #e0e0e0;
            box-shadow: 0 0 30px rgba(0,0,0,0.9);
            image-rendering: pixelated;
            border: 1px solid #333;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }

        #os-text {
            position: absolute;
            top: 10px; left: 10px;
            color: #000;
            font-family: 'VT323', monospace; /* Retro font */
            font-size: 20px;
            line-height: 1.1;
            font-weight: bold;
            z-index: 10;
            display: none;
            white-space: pre;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
        }

        /* --- CHASSIS & CONTROLS --- */
        #faceplate {
            background-color: var(--case-black);
            padding: 15px;
            padding-bottom: calc(20px + var(--safe-area-bottom));
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-top: 2px solid #333;
            box-shadow: inset 0 2px 5px rgba(255,255,255,0.1);
        }

        /* The Rainbow Logo Bar */
        .sinclair-branding {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
            padding-right: 10px;
            margin-bottom: 5px;
        }

        .logo-text {
            font-family: Arial, sans-serif;
            /* text-transform: uppercase; Removed so JV's SpecTape casing works */
            font-weight: bold;
            font-size: 14px; /* Slightly larger to match original weight */
            color: #888;
            letter-spacing: 0.5px;
            font-style: italic;
        }

        .rainbow-stripe {
            width: 80px;
            height: 6px;
            background: linear-gradient(to right, 
                var(--sp-red) 0%, var(--sp-red) 25%, 
                var(--sp-yellow) 25%, var(--sp-yellow) 50%, 
                var(--sp-green) 50%, var(--sp-green) 75%, 
                var(--sp-blue) 75%, var(--sp-blue) 100%
            );
            transform: skewX(-20deg);
        }

        #controls {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        /* --- RUBBER KEYS CSS --- */
        .rubber-key {
            background: var(--key-grey);
            border: none;
            color: #eee;
            padding: 15px 20px;
            font-family: Arial, sans-serif; /* Authentic key font */
            font-weight: bold;
            font-size: 14px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            cursor: pointer;
            position: relative;
            
            /* The "Rubber" Look */
            box-shadow: 
                inset 1px 1px 3px rgba(255,255,255,0.15), /* Top highlight */
                inset -1px -1px 3px rgba(0,0,0,0.5),      /* Bottom shadow */
                0 6px 0 #111,                              /* 3D Depth */
                0 8px 5px rgba(0,0,0,0.4);                 /* Drop shadow */
            transition: all 0.1s ease;
            width: 100px;
        }

        /* Keyword coloring (like "LOAD" in red) */
        .rubber-key span.cmd {
            color: var(--sp-red);
            font-size: 11px;
            margin-bottom: 2px;
        }
        
        .rubber-key span.label {
            color: #fff;
            font-size: 16px;
        }

        /* Press Animation */
        .rubber-key:active {
            transform: translateY(6px); /* Move down */
            box-shadow: 
                inset 1px 1px 5px rgba(0,0,0,0.5), 
                0 0 0 #111, 
                0 0 0 rgba(0,0,0,0);
        }

        /* --- BORDER ANIMATIONS --- */
        .pilot-border { animation: pilot 0.04s infinite step-end; }
        .data-border { animation: data 0.04s infinite step-end; }

        @keyframes pilot {
            0% { background-color: var(--sp-red); }
            50% { background-color: var(--sp-cyan); }
        }
        @keyframes data {
            0% { background-color: var(--sp-blue); }
            25% { background-color: var(--sp-yellow); }
            50% { background-color: var(--sp-blue); } 
            75% { background-color: var(--sp-yellow); }
        }

        /* --- HIDDEN ENGINE ROOM --- */
        #hidden-engine { display: none; }
    </style>
</head>
<body>

    <div id="viewport">
        <div id="stage">
            <canvas id="visibleCanvas" width="256" height="192"></canvas>
            <div id="os-text"></div>
        </div>
    </div>

    <div id="faceplate">
        <div class="sinclair-branding">
            <span class="logo-text">JV's SpecTape</span>
            <div class="rainbow-stripe"></div>
        </div>

        <div id="controls">
            <label class="rubber-key">
                <span class="cmd">LOAD ""</span>
                <span class="label">J</span>
                <input type="file" id="fileInput" accept="image/*" style="display:none" onchange="handleFile(this)">
            </label>

            <div class="rubber-key" onclick="saveImage()">
                <span class="cmd">SAVE</span>
                <span class="label">S</span>
            </div>
        </div>
    </div>

    <div id="hidden-engine">
        <img id="refImg" crossorigin="anonymous">
        <canvas id="speccyCanvas" width="256" height="192"></canvas>
        <canvas id="attrCanvas" width="256" height="192"></canvas>
        <canvas id="compositeCanvas" width="256" height="192"></canvas>
    </div>

    <script>
        // --- 1. AUDIO ENGINE (Generative) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let osc = null, gain = null;

        function playTone(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (osc) stopTone();
            osc = audioCtx.createOscillator();
            gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'square';
            gain.gain.value = 0.1; 

            if (type === 'pilot') {
                osc.frequency.setValueAtTime(800, audioCtx.currentTime); 
            } else if (type === 'data') {
                osc.frequency.setValueAtTime(1000, audioCtx.currentTime);
                const now = audioCtx.currentTime;
                // Generate chaotic data crunching sound
                for(let i=0; i<100; i++) {
                    osc.frequency.setValueAtTime(Math.random() > 0.5 ? 1200 : 2000, now + (i*0.02));
                }
            }
            osc.start();
        }

        function stopTone() {
            if (osc) {
                try { osc.stop(); osc.disconnect(); } catch(e){}
                osc = null;
            }
        }

        // --- 2. CONVERSION ENGINE ---
        const speccyCanvas = document.getElementById('speccyCanvas');
        const ctx = speccyCanvas.getContext('2d', {willReadFrequently: true});
        const attrCanvas = document.getElementById('attrCanvas');
        const attrCtx = attrCanvas.getContext('2d');
        
        // Composite canvas to flatten layers for the animation
        const compositeCanvas = document.getElementById('compositeCanvas');
        const compCtx = compositeCanvas.getContext('2d');
        
        const refImg = document.getElementById('refImg');
        const visibleCanvas = document.getElementById('visibleCanvas');
        const visibleCtx = visibleCanvas.getContext('2d');

        let attrData = new Array(768).fill(56); 
        const PALETTE = ['#000000', '#0000D7', '#D70000', '#D700D7', '#00D700', '#00D7D7', '#D7D700', '#FFFFFF'];

        function autoConvertImage() {
            // A. Create temp canvas for scaling
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 256; tempCanvas.height = 192;
            const tCtx = tempCanvas.getContext('2d');
            
            tCtx.fillStyle = "white";
            tCtx.fillRect(0, 0, 256, 192);
            
            // Centre and Scale (Preserving Aspect Ratio)
            const w = refImg.naturalWidth, h = refImg.naturalHeight;
            const s = Math.min(256/w, 192/h);
            const dx = (256-w*s)/2, dy = (192-h*s)/2;
            tCtx.drawImage(refImg, dx, dy, w*s, h*s);

            // B. Get RAW Pixels (No Filters!)
            const imgDataObj = tCtx.getImageData(0, 0, 256, 192);
            const pixels = imgDataObj.data;

            // C. Clear hidden Canvases
            ctx.clearRect(0, 0, 256, 192); // Speccy Pixels
            attrCtx.clearRect(0, 0, 256, 192); // Attributes
            attrData.fill(56);

            // D. Run Block Logic
            for (let by = 0; by < 24; by++) {
                for (let bx = 0; bx < 32; bx++) {
                    processBlock(bx, by, pixels);
                }
            }
            
            // E. Draw Colours
            redrawAttributes();

            // F. COMPOSITE (Flatten layers into one image for the animation)
            compCtx.fillStyle = "white"; 
            compCtx.fillRect(0,0,256,192); // White base
            
            // 1. Draw Attributes
            compCtx.globalAlpha = 1.0;
            compCtx.drawImage(attrCanvas, 0, 0);
            
            // 2. Draw Pixels
            compCtx.globalAlpha = 1.0;
            compCtx.drawImage(speccyCanvas, 0, 0);
        }

        function processBlock(bx, by, pixels) {
            let blockColors = [];
            
            for (let py = 0; py < 8; py++) {
                for (let px = 0; px < 8; px++) {
                    const idx = (((by * 8 + py) * 256) + (bx * 8 + px)) * 4;
                    const r = pixels[idx], g = pixels[idx+1], b = pixels[idx+2];
                    
                    // Simple brightness calculation
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    
                    // If dark, draw a black pixel on the pixel layer
                    if (brightness < 128) {
                        ctx.fillStyle = "black";
                        ctx.fillRect(bx * 8 + px, by * 8 + py, 1, 1);
                    }
                    
                    // Collect colour for attribute decision
                    blockColors.push(getNearestSpeccyColor(r, g, b));
                }
            }
            
            // Determine dominant colour for this block
            const counts = {};
            blockColors.forEach(c => counts[c] = (counts[c] || 0) + 1);
            const sorted = Object.keys(counts).sort((a, b) => counts[b] - counts[a]);
            
            // Set Attribute
            attrData[by * 32 + bx] = (parseInt(sorted[0]) * 8);
        }

        function getNearestSpeccyColor(r, g, b) {
            let minDist = Infinity, bestIndex = 0;
            const specRGB = [
                [0,0,0],       // 0 Black
                [0,0,215],     // 1 Blue
                [215,0,0],     // 2 Red
                [215,0,215],   // 3 Magenta
                [0,215,0],     // 4 Green
                [0,215,215],   // 5 Cyan
                [215,215,0],   // 6 Yellow
                [255,255,255]  // 7 White
            ];
            
            specRGB.forEach((rgb, i) => {
                const d = Math.sqrt((r-rgb[0])**2 + (g-rgb[1])**2 + (b-rgb[2])**2);
                if (d < minDist) { minDist = d; bestIndex = i; }
            });
            return bestIndex;
        }

        function redrawAttributes() {
            attrCtx.clearRect(0, 0, 256, 192); 
            for (let i = 0; i < 768; i++) { 
                const paper = (attrData[i] >> 3) & 7; 
                if (paper !== 7) { 
                    attrCtx.fillStyle = PALETTE[paper]; 
                    attrCtx.fillRect((i % 32) * 8, Math.floor(i / 32) * 8, 8, 8); 
                } 
            }
        }

        // --- 3. ANIMATION LOGIC ---
        const viewPort = document.getElementById('viewport');
        const osText = document.getElementById('os-text');

        function handleFile(input) {
            if(!input.files[0]) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                refImg.src = e.target.result;
                refImg.onload = () => {
                    // 1. Run conversion immediately (In background)
                    autoConvertImage(); 
                    // 2. Start animation sequence
                    startLoadingSequence();
                };
            };
            reader.readAsDataURL(input.files[0]);
        }

        function startLoadingSequence() {
            // Reset Screen
            visibleCtx.fillStyle = "#e0e0e0"; visibleCtx.fillRect(0,0,256,192);
            osText.style.display = 'block'; osText.innerText = "";
            
            // Phase 1: Pilot
            playTone('pilot');
            viewPort.className = 'pilot-border';
            
            setTimeout(() => { osText.innerText = "Program: loader"; }, 800);

            setTimeout(() => {
                // Phase 2: Data
                viewPort.className = 'data-border';
                osText.innerText += "\nBytes: image";
                playTone('data');
                setTimeout(() => { osText.style.display = 'none'; }, 200);

                // Start Line Renderer
                startLineRenderer();
            }, 2500);
        }

        function startLineRenderer() {
            let y = 0;
            const step = 2; // Pixels per tick
            const timer = setInterval(() => {
                if (y >= 192) {
                    clearInterval(timer);
                    finishLoading();
                    return;
                }
                // Copy from the COMPOSITE canvas
                visibleCtx.drawImage(compositeCanvas, 0, y, 256, step, 0, y, 256, step);
                y += step;
                if(osc && Math.random() > 0.8) {
                    osc.frequency.setValueAtTime(Math.random()*1000 + 500, audioCtx.currentTime);
                }
            }, 15);
        }

        function finishLoading() {
            stopTone();
            viewPort.className = '';
            viewPort.style.background = '#000';
        }

        function saveImage() {
            const link = document.createElement('a');
            link.download = 'zx-art.png';
            link.href = compositeCanvas.toDataURL(); // Save the flattened result
            link.click();
        }
    </script>
</body>
</html>
